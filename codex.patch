 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/docs/FRONTEND_ARCHITECTURE.md b/docs/FRONTEND_ARCHITECTURE.md
new file mode 100644
index 0000000000000000000000000000000000000000..d35961a24770e4f3db7a5a9ced2cfd63ba1b680a
--- /dev/null
+++ b/docs/FRONTEND_ARCHITECTURE.md
@@ -0,0 +1,31 @@
+# Frontend Architecture Notes
+
+This document tracks the emerging structure for the Angular frontend as we move logic out of `src/app/app.ts`.
+
+## Directory layout (work in progress)
+```
+src/app/
+  core/
+    models/              # Shared TypeScript interfaces
+    services/
+      api/               # API clients (axios-based for now)
+  features/
+    graph/
+      services/          # Graph-specific helpers (Cytoscape, mapping)
+```
+
+### Key responsibilities
+- **`core/models`**: Types for skills, relations, and category colors shared across features.
+- **`core/services/api`**: API client layer. `TechTreeApiService` centralizes node/relation CRUD so components avoid inline axios calls.
+- **`features/graph/services/graph-data.service.ts`**: Maps domain data into Cytoscape element definitions and centralizes category color generation.
+
+### Migration guidelines
+- Prefer adding new feature-specific helpers under `src/app/features/<feature>/` rather than expanding `app.ts`.
+- Add shared data contracts to `core/models` and reference them instead of `any`.
+- Route all HTTP calls through `TechTreeApiService` (or a sibling service) to keep components UI-focused.
+- If you introduce new Cytoscape helpers or layout tweaks, colocate them under `features/graph/`.
+
+### Next steps to continue the split
+- Extract graph rendering into a dedicated `GraphViewComponent` that consumes `GraphDataService` output.
+- Move table and editor forms into feature-scoped components with local state services.
+- Convert axios usage in `TechTreeApiService` to Angular `HttpClient` once the app is bootstrapped with `HttpClientModule`.
diff --git a/docs/README.md b/docs/README.md
index 074bc8e498a7036f3071dcbd7958434fe95c68a0..28eecadd825d4a5732abf989cb88e87ed0d50450 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -1,52 +1,55 @@
 # TechTree — ドキュメント
 
 ## 概要
 TechTree は技術ノード間の関係（ノード + エッジ）を可視化する Web アプリケーションです。
 フロントエンドは Angular + Cytoscape.js、バックエンドは Django REST Framework を使用しています。
 
 ## 関連 OSS / ライブラリ
 - フレームワーク / ランタイム
   - Angular (v21), Node.js (dev)
   - Django, Django REST Framework
 - フロントエンド
   - cytoscape.js — グラフ可視化
   - cytoscape-dagre (dagre) — レイアウトプラグイン
   - axios — HTTP クライアント
 - バックエンド / DB
   - PostgreSQL
   - django-cors-headers
 - 開発ツール
   - Angular CLI, Vitest(テストランナー)
 
 ## 主要ファイル・設定箇所
 - フロントエンド
   - src/app/app.ts — Cytoscape 初期化、イベント、レイアウト操作
+  - src/app/core/services/api/tech-tree-api.service.ts — ノード/リレーションの API 呼び出しを集約
+  - src/app/features/graph/services/graph-data.service.ts — ノード/リレーションを Cytoscape 要素へ変換し、カテゴリ色を管理
   - src/app/visual-config.ts — 表示に関する集中設定（layoutConfig, levelNodeConfig, mainLabelConfig）
   - src/app/style-variables.css — グローバル CSS 変数
   - src/app/app.css / src/styles.css — UI スタイル
   - src/app/app.html — ヘッダー・検索・サイドバー・cy コンテナ（#cy）
+  - docs/FRONTEND_ARCHITECTURE.md — フロントエンドのフォルダ構成と移行方針メモ
 - バックエンド
   - skills アプリ: skills/models.py（Node / Relation モデルと API）
   - backend/settings.py — DB / CORS / INSTALLED_APPS 等
 
 ## データモデルメモ
 - グラフ型の技術知識モデルの方針は `docs/GRAPH_MODEL.md` を参照してください（nodes / relations テーブル、relation_type / strength / context など）。
 
 ## 画面機能（ユーザー視点）
 - ヘッダー
   - ロゴ、ツールバー（Fit / Zoom / Layout 切替 / Clear / サイドバー切替）
   - 検索入力（ノード名でフィルタ）
 - メイン
   - Cytoscape によるノード/エッジ表示
   - ノードをクリックすると詳細がサイドバーに表示
 - サイドバー
   - 選択ノードの Label / Category / Level を表示
   - 折りたたみ可能
 
 ## 編集モードの使い方
 - グラフ表示のみで有効（テーブル表示時はボタンが無効化され、ONのまま切り替えると自動でOFFになります）。
 - ヘッダーの「編集モード」をONにすると、次の操作ができるようになります。
   - ノードをドラッグして画面上の配置を調整（見た目のみ、サーバーへは送信されません）。
   - 画面上部の編集パネルから新規ノードを追加（親IDを指定すると親子関係を作成）。
   - 選択中ノードの説明を保存、不要なノードは「ノードを削除」で削除。
   - カテゴリ名と色を入力し「カテゴリ色を保存」を押すと、対象カテゴリの色が即時で全ノードに反映。
diff --git a/techtree-frontend/README.md b/techtree-frontend/README.md
index 1f3d0beaa226724402d6dd1f9848499631177357..ff9a26c88111895b04f75118d276f801d99824a2 100644
--- a/techtree-frontend/README.md
+++ b/techtree-frontend/README.md
@@ -1,29 +1,31 @@
 # TechtreeFrontend
 
 This project was generated using [Angular CLI](https://github.com/angular/angular-cli) version 21.0.1.
 
+Architecture and folder layout notes: see [`docs/FRONTEND_ARCHITECTURE.md`](../docs/FRONTEND_ARCHITECTURE.md).
+
 ## Development server
 
 To start a local development server, run:
 
 ```bash
 ng serve
 ```
 
 Once the server is running, open your browser and navigate to `http://localhost:4200/`. The application will automatically reload whenever you modify any of the source files.
 
 ## Code scaffolding
 
 Angular CLI includes powerful code scaffolding tools. To generate a new component, run:
 
 ```bash
 ng generate component component-name
 ```
 
 For a complete list of available schematics (such as `components`, `directives`, or `pipes`), run:
 
 ```bash
 ng generate --help
 ```
 
 ## Building
diff --git a/techtree-frontend/src/app/app.ts b/techtree-frontend/src/app/app.ts
index 10be36df939563f1c1b961c400e8ebfef774d419..3b679bc0f7c68fe02e6ca28a1056f9f2dd7ac028 100644
--- a/techtree-frontend/src/app/app.ts
+++ b/techtree-frontend/src/app/app.ts
@@ -1,66 +1,69 @@
 import { Component, OnInit, AfterViewInit, ChangeDetectorRef, NgZone, HostListener } from '@angular/core';
 import { CommonModule } from '@angular/common';
 import { FormsModule } from '@angular/forms';
 import cytoscape from 'cytoscape';
 import dagre from 'cytoscape-dagre';
-import axios from 'axios';
 import { layoutConfig, levelNodeConfig, mainLabelConfig } from './visual-config';
-import { environment } from '../environments/environment';
+import { TechTreeApiService } from './core/services/api/tech-tree-api.service';
+import { Skill } from './core/models/skill.model';
+import { Relation } from './core/models/relation.model';
+import { CategoryColor } from './core/models/category-color.model';
+import { GraphDataService } from './features/graph/services/graph-data.service';
 
 cytoscape.use(dagre);
 
 @Component({
   selector: 'app-root',
   standalone: true,
   imports: [CommonModule, FormsModule],
   templateUrl: './app.html',
   styleUrls: ['./app.css']
 })
 export class AppComponent implements OnInit, AfterViewInit {
   cy: any = null;
   selectedNode: any = null;
   searchTerm = '';
   levelMenuOpen = false;
   categoryMenuOpen = false;
   selectedLevels: Set<number> = new Set();
   selectedCategories: Set<string> = new Set();
   levelOptions: number[] = [];
   categoryOptions: string[] = [];
   categoryColors: Record<string, string> = {};
-  categoryList: { id: number; name: string; color: string }[] = [];
+  categoryList: CategoryColor[] = [];
   sidebarCollapsed = false;
   layoutName = 'dagre';
   //layoutName = 'breadthfirst';
 
   elements: any[] = []; // store node + edge elements until cy is initialized
 
   // table / view state
   viewMode: 'graph' | 'table' = 'graph';
-  skills: any[] = [];
-  relations: any[] = [];
-  filteredTableRows: any[] = [];
+  skills: Skill[] = [];
+  relations: Relation[] = [];
+  filteredTableRows: Skill[] = [];
   sortState: {
     column: 'label' | 'category' | 'level' | 'user_comment' | 'description';
     direction: 'asc' | 'desc';
   } = {
     column: 'label',
     direction: 'asc'
   };
 
   editingMode = false;
   newSkill = {
     name: '',
     category: '',
     level: 0,
     description: ''
   };
   newSkillError = '';
   newSkillNotice = '';
   editingCategory = {
     name: '',
     color: '#4a5568'
   };
   selectedCategoryName = '';
   metadataSaveMessage = '';
   metadataSaveIsError = false;
   skillNameOptions: string[] = [];
@@ -69,72 +72,77 @@ export class AppComponent implements OnInit, AfterViewInit {
     id: number;
     direction: 'incoming' | 'outgoing';
     targetName: string;
     relation_type: string;
     strength: number;
   }[] = [];
   connectionForm = {
     targetName: '',
     relationType: 'prerequisite',
     direction: 'outgoing' as 'outgoing' | 'incoming',
     strength: 0.5
   };
   connectionError = '';
   connectionNotice = '';
   selectedConnectionId: number | null = null;
 
   // --------------------------
   // Centralized layout config
   // --------------------------
   // replaced inline definitions with imported configs
   readonly layoutConfig = layoutConfig;
   readonly levelNodeConfig = levelNodeConfig;
   readonly mainLabelConfig = mainLabelConfig;
 
   // inject ChangeDetectorRef and NgZone so Cytoscape callbacks can update Angular view
-  constructor(private cdr: ChangeDetectorRef, private ngZone: NgZone) { }
+  constructor(
+    private cdr: ChangeDetectorRef,
+    private ngZone: NgZone,
+    private apiService: TechTreeApiService,
+    private graphDataService: GraphDataService
+  ) { }
 
   // Helper: return layout options for a layout name
   getLayoutOptions(layoutName?: string) {
     const name = layoutName ?? this.layoutName;
     // Use `any` to avoid typing issues with cytoscape layout typed options
     return (this.layoutConfig as any)[name] ?? (this.layoutConfig as any).dagre;
   }
 
   async ngOnInit() {
     try {
-      const [nodeRes, relationRes] = await Promise.all([
-        axios.get(`${environment.apiUrl}/nodes/`),
-        axios.get(`${environment.apiUrl}/relations/`)
+      const [skillsResponse, relationResponse] = await Promise.all([
+        this.apiService.fetchSkills(),
+        this.apiService.fetchRelations()
       ]);
-      const skills = (nodeRes.data ?? []).map((n: any) => ({
-        ...n,
-        level: n.level ?? 0,
-        user_comment: n.user_comment ?? '',
+      const skills = (skillsResponse ?? []).map((skill) => ({
+        ...skill,
+        level: skill.level ?? 0,
+        user_comment: skill.user_comment ?? '',
         parent_id: null
       }));
-      this.relations = relationRes.data ?? [];
+      this.relations = relationResponse ?? [];
       console.log('nodes fetched', skills?.length, 'relations fetched', this.relations?.length);
 
       this.skills = skills ?? [];
       this.rebuildElementsFromSkills();
       if (!this.editingCategory.name && this.categoryOptions.length > 0) {
         this.editingCategory.name = this.categoryOptions[0];
       }
     } catch (error) {
       console.error('Failed to fetch skills', error);
       this.elements = [];
     }
   }
 
   ngAfterViewInit() {
     // Initialize cytoscape after the view is available
     this.initCytoscape();
 
     // If data already fetched (even if empty array), add elements so demo fallback renders when empty
     if (this.elements) {
       this.addElementsToCytoscape(this.elements);
     }
   }
 
   initCytoscape() {
     const container = document.getElementById('cy');
@@ -800,287 +808,237 @@ export class AppComponent implements OnInit, AfterViewInit {
     });
 
     const sorted = mapped.sort((a, b) => a.targetName.localeCompare(b.targetName));
     const stillSelected = sorted.some((r) => r.id === this.selectedConnectionId);
 
     this.selectedConnections = sorted;
 
     if (!stillSelected) {
       this.selectedConnectionId = null;
       this.resetConnectionForm();
     } else if (this.selectedConnectionId) {
       const selected = sorted.find((r) => r.id === this.selectedConnectionId);
       if (selected) {
         this.connectionForm = {
           targetName: selected.targetName ?? '',
           relationType: selected.relation_type ?? 'prerequisite',
           direction: selected.direction ?? 'outgoing',
           strength: Math.max(0, Math.min(1, Number(selected.strength ?? 0.5)))
         };
       }
     }
   }
 
   private async ensureCategoryColor(name: string) {
     if (!name) return '#d1d5db';
-    if (this.categoryColors[name]) return this.categoryColors[name];
-
-    const color = this.generateRandomColor();
-    this.categoryColors[name] = color;
+    const color = this.graphDataService.ensureCategoryColor(this.categoryColors, name);
     this.categoryOptions = Array.from(new Set([...this.categoryOptions, name])).sort();
     this.selectedCategories.add(name);
 
     try {
       await this.saveCategoryColorInternal(name, color);
     } catch (err) {
       console.warn('Failed to persist category color, using local only', err);
     }
 
     return color;
   }
 
-  private generateRandomColor() {
-    const component = () => Math.floor(Math.random() * 156 + 80).toString(16).padStart(2, '0');
-    return `#${component()}${component()}${component()}`;
-  }
-
   private rebuildElementsFromSkills() {
-    // refresh categories/colors from current nodes
-    const previousColors = { ...this.categoryColors };
-    this.categoryColors = {};
-    (this.skills ?? []).forEach((s: any) => {
-      if (!this.categoryColors[s.category]) {
-        this.categoryColors[s.category] = previousColors[s.category] ?? this.generateRandomColor();
-      }
-    });
-    this.categoryList = Object.entries(this.categoryColors).map(([name, color], idx) => ({
-      id: idx + 1,
-      name,
-      color
-    }));
-
-    const nodeElements = (this.skills ?? []).map((s: any) => ({
-      data: {
-        id: `skill-${s.id}`,
-        label: s.name,
-        category: s.category,
-        color: this.categoryColors[s.category] ?? '#d1d5db',
-        level: s.level,
-        description: s.description,
-        user_comment: s.user_comment,
-        tags: s.tags ?? []
-      }
-    }));
-
-    const edgeElements = (this.relations ?? [])
-      .map((r: any) => {
-        const from = r.from_node_id ?? r.from_node?.id;
-        const to = r.to_node_id ?? r.to_node?.id;
-        if (from == null || to == null) return null;
-        return {
-          data: {
-            id: `relation-${r.id}`,
-            source: `skill-${from}`,
-            target: `skill-${to}`,
-            relation_type: r.relation_type,
-            strength: r.strength,
-            context: r.context
-          }
-        };
-      })
-      .filter((el): el is { data: any } => !!el);
-
-    this.elements = [...nodeElements, ...edgeElements];
+    const graphState = this.graphDataService.buildGraphState(this.skills ?? [], this.relations ?? [], this.categoryColors);
+    this.categoryColors = graphState.categoryColors;
+    this.categoryList = graphState.categoryList;
+    this.elements = graphState.elements;
 
     this.refreshCategoryOptionsFromState();
     this.refreshLevelOptionsFromSkills();
     this.refreshSkillNameOptions();
 
     if (this.cy) {
       this.addElementsToCytoscape(this.elements);
       this.refreshViewport();
     }
 
     this.refreshTableRows();
     this.refreshSelectedConnections();
   }
 
   private resolveSkillNameById(id: number | null | undefined) {
     if (id === null || id === undefined) return '';
     const skill = (this.skills ?? []).find((s: any) => Number(s.id) === Number(id));
     return skill?.name ?? '';
   }
 
   private extractSkillId(raw: any): number | null {
     const str = String(raw ?? '');
     const match = str.match(/(\d+)/);
     return match ? Number(match[1]) : null;
   }
 
-  private async pushSkillToState(skill: any) {
+  private async pushSkillToState(skill: Skill) {
     this.skills.push(skill);
     await this.ensureCategoryColor(skill.category);
     this.rebuildElementsFromSkills();
   }
 
   private async createRelation(fromId: number, toId: number, relation_type: string, strength: number) {
     const payload = {
       from_node_id: fromId,
       to_node_id: toId,
       relation_type,
       strength
     };
-    const res = await axios.post(`${environment.apiUrl}/relations/`, payload);
-    const created = res.data ?? { ...payload, id: Date.now() };
+    const created = await this.apiService.createRelation(payload);
+    const fallback = { ...payload, id: Date.now() };
+    const normalizedSource = created ?? fallback;
     const normalized = {
-      id: created.id ?? Date.now(),
-      from_node_id: created.from_node_id ?? created.from_node ?? fromId,
-      to_node_id: created.to_node_id ?? created.to_node ?? toId,
-      relation_type: created.relation_type ?? relation_type,
-      strength: created.strength ?? strength
+      id: normalizedSource.id ?? Date.now(),
+      from_node_id: normalizedSource.from_node_id ?? normalizedSource.from_node ?? fromId,
+      to_node_id: normalizedSource.to_node_id ?? normalizedSource.to_node ?? toId,
+      relation_type: normalizedSource.relation_type ?? relation_type,
+      strength: normalizedSource.strength ?? strength
     };
     this.relations = [...this.relations, normalized];
     this.rebuildElementsFromSkills();
     return normalized.id;
   }
 
   async createSkill() {
     if (!this.editingMode || this.viewMode !== 'graph') return;
     this.newSkillError = '';
     this.newSkillNotice = '';
 
     const name = this.newSkill.name.trim();
     const category = this.newSkill.category.trim();
     const level = Number(this.newSkill.level);
     const errors: string[] = [];
 
     if (!name) errors.push('名前を入力してください');
     if (!category) errors.push('カテゴリを入力してください');
     if (!Number.isFinite(level) || level < 0 || level > 5) errors.push('レベルは0-5の数値で入力してください');
 
     const nameExists = (this.skills ?? []).some(
       (s: any) => (s?.name ?? s?.label ?? '').toLowerCase() === name.toLowerCase()
     );
     if (nameExists) errors.push('同名のノードが既に存在します');
 
     if (errors.length > 0) {
       this.newSkillError = errors.join(' / ');
       return;
     }
 
     const payload = {
       name,
       category,
       description: this.newSkill.description ?? '',
       tags: [] as string[],
       node_type: 'technology'
     };
 
     await this.ensureCategoryColor(category);
-    const response = await axios.post(`${environment.apiUrl}/nodes/`, payload);
-    const created = response.data;
+    const created = await this.apiService.createSkill(payload);
     created.parent_id = null;
     created.level = this.clampLevelValue(level);
     created.user_comment = '';
     await this.pushSkillToState(created);
     this.newSkill = { name: '', category: '', level: 0, description: '' };
     this.newSkillNotice = 'ノードを追加しました';
   }
 
   async deleteSelectedSkill() {
     if (!this.editingMode || this.viewMode !== 'graph' || !this.selectedNode) return;
     const match = String(this.selectedNode.id ?? '').match(/^skill-(\d+)$/);
     if (!match) return;
     const id = Number(match[1]);
-    await axios.delete(`${environment.apiUrl}/nodes/${id}/`);
+    await this.apiService.deleteSkill(id);
     this.elements = this.elements.filter((el) => {
       return !(
         (el.data?.id && String(el.data.id) === `skill-${id}`) ||
         (el.data?.id && String(el.data.id) === `skill-${id}-level`) ||
         (el.data?.source && String(el.data.source) === `skill-${id}`) ||
         (el.data?.target && String(el.data.target) === `skill-${id}`)
       );
     });
     this.skills = this.skills.filter((s: any) => Number(s.id) !== id);
     this.relations = (this.relations ?? []).filter((r: any) => {
       const from = r.from_node_id ?? r.from_node?.id;
       const to = r.to_node_id ?? r.to_node?.id;
       return Number(from) !== id && Number(to) !== id;
     });
     if (this.cy) {
       this.addElementsToCytoscape(this.elements);
     }
     this.clearSelection();
     this.refreshTableRows();
   }
 
   async saveDescription() {
     if (!this.editingMode || !this.selectedNode) return;
     const match = String(this.selectedNode.id ?? '').match(/^skill-(\d+)$/);
     if (!match) return;
     const id = Number(match[1]);
-    await axios.patch(`${environment.apiUrl}/nodes/${id}/`, { description: this.selectedNode.description ?? '' });
+    await this.apiService.updateSkill(id, { description: this.selectedNode.description ?? '' });
     const target = this.skills.find((s: any) => Number(s.id) === id);
     if (target) target.description = this.selectedNode.description;
     this.refreshTableRows();
   }
 
   onEditingCategoryChange(name: string) {
     this.editingCategory = {
       name,
       color: this.categoryColors[name] ?? this.editingCategory.color
     };
   }
 
   async saveSelectedMetadata() {
     if (!this.editingMode || !this.selectedNode) return;
     const match = String(this.selectedNode.id ?? '').match(/^skill-(\d+)$/);
     if (!match) return;
 
     const skillId = Number(match[1]);
     const category = this.selectedCategoryName.trim();
 
     const errors: string[] = [];
     if (!category) errors.push('カテゴリを入力してください');
 
     if (errors.length > 0) {
       this.metadataSaveMessage = errors.join(' / ');
       this.metadataSaveIsError = true;
       return;
     }
 
     const payload: any = {};
     if (category && category !== this.selectedNode.category) payload.category = category;
 
     if (Object.keys(payload).length === 0) {
       this.metadataSaveMessage = '変更がありません';
       this.metadataSaveIsError = false;
       return;
     }
 
     await this.ensureCategoryColor(category);
-    await axios.patch(`${environment.apiUrl}/nodes/${skillId}/`, payload);
+    await this.apiService.updateSkill(skillId, payload);
 
     const target = (this.skills ?? []).find((s: any) => Number(s.id) === skillId);
     if (target) {
       if (payload.category) target.category = payload.category;
     }
 
     this.selectedNode = {
       ...this.selectedNode,
       category: payload.category ?? this.selectedNode.category
     } as any;
 
     this.rebuildElementsFromSkills();
     this.metadataSaveMessage = '保存しました';
     this.metadataSaveIsError = false;
     this.selectSkillById(skillId);
   }
 
   async addConnection() {
     if (!this.editingMode || !this.selectedNode) return;
     this.connectionError = '';
     this.connectionNotice = '';
 
     const baseId = this.getSelectedSkillId();
     if (!baseId) {
       this.connectionError = 'ノードを選択してください';
@@ -1161,79 +1119,79 @@ export class AppComponent implements OnInit, AfterViewInit {
     }
     if (Number(targetSkill.id) === baseId) {
       this.connectionError = '同じノード同士は接続できません';
       return;
     }
 
     const direction = this.connectionForm.direction === 'incoming' ? 'incoming' : 'outgoing';
     const relationType = this.connectionForm.relationType || 'prerequisite';
     const strength = Math.max(0, Math.min(1, Number(this.connectionForm.strength ?? 0.5)));
 
     const fromId = direction === 'outgoing' ? baseId : Number(targetSkill.id);
     const toId = direction === 'outgoing' ? Number(targetSkill.id) : baseId;
 
     const exists = (this.relations ?? []).some((r: any) => {
       if (Number(r.id) === this.selectedConnectionId) return false;
       const from = r.from_node_id ?? r.from_node?.id;
       const to = r.to_node_id ?? r.to_node?.id;
       return Number(from) === fromId && Number(to) === toId;
     });
     if (exists) {
       this.connectionError = '同じ接続が既に存在します';
       return;
     }
 
     try {
-      await axios.patch(`${environment.apiUrl}/relations/${this.selectedConnectionId}/`, {
+      await this.apiService.updateRelation(this.selectedConnectionId, {
         from_node_id: fromId,
         to_node_id: toId,
         relation_type: relationType,
         strength
       });
 
       this.relations = (this.relations ?? []).map((r: any) =>
         Number(r.id) === this.selectedConnectionId
           ? { ...r, from_node_id: fromId, to_node_id: toId, relation_type: relationType, strength }
           : r
       );
 
       this.rebuildElementsFromSkills();
       this.refreshSelectedConnections(baseId);
       this.connectionNotice = '接続を更新しました';
     } catch (err) {
       console.error('Failed to update connection', err);
       this.connectionError = '接続の更新に失敗しました';
     }
   }
 
   async removeConnection(relationId: number) {
     if (!this.editingMode) return;
     this.connectionNotice = '';
     const baseId = this.getSelectedSkillId();
 
     try {
-      await axios.delete(`${environment.apiUrl}/relations/${relationId}/`);
+      await this.apiService.deleteRelation(relationId);
       this.relations = (this.relations ?? []).filter((r: any) => Number(r.id) !== Number(relationId));
       this.rebuildElementsFromSkills();
       this.refreshSelectedConnections();
       this.connectionError = '';
       this.connectionNotice = '接続を削除しました';
     } catch (err) {
       console.error('Failed to remove connection', err);
       this.connectionError = '接続の削除に失敗しました';
     }
   }
 
   async saveCategoryColor() {
     if (!this.editingCategory.name.trim()) return;
     await this.saveCategoryColorInternal(this.editingCategory.name.trim(), this.editingCategory.color.trim());
     this.editingCategory = { name: '', color: '#4a5568' };
   }
 
   private async saveCategoryColorInternal(name: string, color: string) {
     const existing = this.categoryList.find((c) => c.name === name);
     if (existing) {
       existing.color = color;
     } else {
       this.categoryList.push({ id: Date.now(), name, color });
     }
     this.categoryColors[name] = color;
@@ -1658,51 +1616,51 @@ export class AppComponent implements OnInit, AfterViewInit {
     if (this.selectedNode && this.selectedNode.id === nodeId) {
       this.selectedNode = { ...this.selectedNode, ...payload };
       if (payload.level != null) this.selectedLevel = payload.level;
       if (payload.user_comment != null) {
         this.selectedComment = payload.user_comment;
         this.editedComment = payload.user_comment;
       }
     }
 
     this.refreshTableRows();
   }
 
   private async saveSkill(
     skillId: number,
     payload: { level?: number; user_comment?: string; description?: string; category?: string; tags?: string[] },
     originalLevel?: number
   ) {
     if (!payload || Object.keys(payload).length === 0) return;
   
     const allowedPayload: any = {};
     if (payload.description !== undefined) allowedPayload.description = payload.description;
     if (payload.category !== undefined) allowedPayload.category = payload.category;
     if (payload.tags !== undefined) allowedPayload.tags = payload.tags;
 
     if (Object.keys(allowedPayload).length > 0) {
-      await axios.patch(`${environment.apiUrl}/nodes/${skillId}/`, allowedPayload);
+      await this.apiService.updateSkill(skillId, allowedPayload);
     }
 
     this.applySkillChanges(skillId, payload);
   
     // options更新（ここでは applyFilters は呼ばない）
     this.refreshLevelOptionsFromGraph();
   
     const needsRelayout = payload.level != null && (payload.level === 0 || originalLevel === 0);
   
     // ここで1回だけ filter & relayout
     this.applyFilters(needsRelayout);
   
     requestAnimationFrame(() => {
       try {
         if (this.cy) {
           this.cy.resize();
           this.fit();
           this.positionLevelNodes();
         }
       } catch { /* ignore */ }
     });
   }
 
   private async persistDetails(change: { level?: number; user_comment?: string }) {
     if (!this.selectedNode) return;
diff --git a/techtree-frontend/src/app/core/models/category-color.model.ts b/techtree-frontend/src/app/core/models/category-color.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..38fafdd71864cc538d03340b1c311d42a20363ab
--- /dev/null
+++ b/techtree-frontend/src/app/core/models/category-color.model.ts
@@ -0,0 +1,5 @@
+export interface CategoryColor {
+  id: number;
+  name: string;
+  color: string;
+}
diff --git a/techtree-frontend/src/app/core/models/relation.model.ts b/techtree-frontend/src/app/core/models/relation.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..64f1f2ab9c6c86166d836ede7a56fbb2839b38e7
--- /dev/null
+++ b/techtree-frontend/src/app/core/models/relation.model.ts
@@ -0,0 +1,10 @@
+export interface Relation {
+  id: number;
+  from_node_id: number;
+  to_node_id: number;
+  relation_type: string;
+  strength?: number;
+  context?: string;
+  from_node?: { id: number };
+  to_node?: { id: number };
+}
diff --git a/techtree-frontend/src/app/core/models/skill.model.ts b/techtree-frontend/src/app/core/models/skill.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..79affae16a46249bdcd2f11596df6c0d21f5b4bf
--- /dev/null
+++ b/techtree-frontend/src/app/core/models/skill.model.ts
@@ -0,0 +1,11 @@
+export interface Skill {
+  id: number;
+  name: string;
+  label?: string;
+  category: string;
+  level: number;
+  description?: string;
+  user_comment?: string;
+  parent_id?: number | null;
+  tags?: string[];
+}
diff --git a/techtree-frontend/src/app/core/services/api/tech-tree-api.service.ts b/techtree-frontend/src/app/core/services/api/tech-tree-api.service.ts
new file mode 100644
index 0000000000000000000000000000000000000000..df7b202b47a53da4f1b1408e7f1a70fbe2a06dc2
--- /dev/null
+++ b/techtree-frontend/src/app/core/services/api/tech-tree-api.service.ts
@@ -0,0 +1,55 @@
+import { Injectable } from '@angular/core';
+import axios from 'axios';
+import { environment } from '../../../../environments/environment';
+import { Skill } from '../../models/skill.model';
+import { Relation } from '../../models/relation.model';
+
+@Injectable({ providedIn: 'root' })
+export class TechTreeApiService {
+  async fetchSkills(): Promise<Skill[]> {
+    const response = await axios.get(`${environment.apiUrl}/nodes/`);
+    return response.data ?? [];
+  }
+
+  async fetchRelations(): Promise<Relation[]> {
+    const response = await axios.get(`${environment.apiUrl}/relations/`);
+    return response.data ?? [];
+  }
+
+  async createSkill(payload: {
+    name: string;
+    category: string;
+    description?: string;
+    tags?: string[];
+    node_type?: string;
+  }): Promise<Skill> {
+    const response = await axios.post(`${environment.apiUrl}/nodes/`, payload);
+    return response.data;
+  }
+
+  async deleteSkill(id: number): Promise<void> {
+    await axios.delete(`${environment.apiUrl}/nodes/${id}/`);
+  }
+
+  async updateSkill(skillId: number, payload: Partial<Skill>): Promise<void> {
+    await axios.patch(`${environment.apiUrl}/nodes/${skillId}/`, payload);
+  }
+
+  async createRelation(payload: {
+    from_node_id: number;
+    to_node_id: number;
+    relation_type: string;
+    strength: number;
+  }): Promise<Relation> {
+    const response = await axios.post(`${environment.apiUrl}/relations/`, payload);
+    return response.data;
+  }
+
+  async updateRelation(relationId: number, payload: Partial<Relation>): Promise<void> {
+    await axios.patch(`${environment.apiUrl}/relations/${relationId}/`, payload);
+  }
+
+  async deleteRelation(relationId: number): Promise<void> {
+    await axios.delete(`${environment.apiUrl}/relations/${relationId}/`);
+  }
+}
diff --git a/techtree-frontend/src/app/features/graph/services/graph-data.service.ts b/techtree-frontend/src/app/features/graph/services/graph-data.service.ts
new file mode 100644
index 0000000000000000000000000000000000000000..764b9a8842556dc218a2c2e2711564371ea2c068
--- /dev/null
+++ b/techtree-frontend/src/app/features/graph/services/graph-data.service.ts
@@ -0,0 +1,78 @@
+import { Injectable } from '@angular/core';
+import { ElementDefinition } from 'cytoscape';
+import { CategoryColor } from '../../../core/models/category-color.model';
+import { Relation } from '../../../core/models/relation.model';
+import { Skill } from '../../../core/models/skill.model';
+
+@Injectable({ providedIn: 'root' })
+export class GraphDataService {
+  buildGraphState(
+    skills: Skill[],
+    relations: Relation[],
+    previousColors: Record<string, string>
+  ): { elements: ElementDefinition[]; categoryColors: Record<string, string>; categoryList: CategoryColor[] } {
+    const categoryColors: Record<string, string> = { ...previousColors };
+
+    skills.forEach((skill) => {
+      if (!categoryColors[skill.category]) {
+        categoryColors[skill.category] = this.generateRandomColor();
+      }
+    });
+
+    const categoryList: CategoryColor[] = Object.entries(categoryColors).map(([name, color], idx) => ({
+      id: idx + 1,
+      name,
+      color
+    }));
+
+    const nodeElements: ElementDefinition[] = skills.map((skill) => ({
+      data: {
+        id: `skill-${skill.id}`,
+        label: skill.name,
+        category: skill.category,
+        color: categoryColors[skill.category] ?? '#d1d5db',
+        level: skill.level,
+        description: skill.description,
+        user_comment: skill.user_comment,
+        tags: skill.tags ?? []
+      }
+    }));
+
+    const edgeElements: ElementDefinition[] = relations
+      .map((relation) => {
+        const from = relation.from_node_id ?? relation.from_node?.id;
+        const to = relation.to_node_id ?? relation.to_node?.id;
+        if (from == null || to == null) return null;
+        return {
+          data: {
+            id: `relation-${relation.id}`,
+            source: `skill-${from}`,
+            target: `skill-${to}`,
+            relation_type: relation.relation_type,
+            strength: relation.strength,
+            context: relation.context
+          }
+        } as ElementDefinition;
+      })
+      .filter((el): el is ElementDefinition => Boolean(el));
+
+    return {
+      elements: [...nodeElements, ...edgeElements],
+      categoryColors,
+      categoryList
+    };
+  }
+
+  ensureCategoryColor(categoryColors: Record<string, string>, category: string): string {
+    if (!category) return '#d1d5db';
+    if (!categoryColors[category]) {
+      categoryColors[category] = this.generateRandomColor();
+    }
+    return categoryColors[category];
+  }
+
+  private generateRandomColor() {
+    const component = () => Math.floor(Math.random() * 156 + 80).toString(16).padStart(2, '0');
+    return `#${component()}${component()}${component()}`;
+  }
+}
 
EOF
)
